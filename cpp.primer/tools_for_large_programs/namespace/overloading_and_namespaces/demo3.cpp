// topic: Overloading and using Directives

#include <iostream>

namespace A {
    void print(int x) { std::cout << "A::print(" << x << ")" << std::endl; }
    void display(int x) { std::cout << "A::display(" << x << ")" << std::endl; }
    void display(double x) { std::cout << "A::display(" << x << ")" << std::endl;  }
}

void print(double x) {
    std::cout << "::print(" << x << ")" << std::endl; 
}

void display(int x) {
    std::cout << "::display(" << x << ")" << std::endl; 
}

// this `using` directive adds names to the candidate set for calls to `print` and `display`.
using namespace A;
// the candidates for calls to `print` at this point in the program are:
//   - `print(int)` from A
//   - `print(double)` declared explicitly
// Differently from how using declarations work, it is not an error if a using directive
// introduces a function that has the same parameters as an existing function.
// Thus, introducing `display(double)` from A does not generate compiling errors.
// the candidates for calls to `display` at this point in the program are:
//   - `A::display(int)`
//   - `A::display(double)`
//   - `::display(int)`


int main() {
    print(1);
    print(3.14);

    // As with other conflicts generated by using directives, there is no problem unless we try to
    // call the function without specifying whether we want the one from the namespace or
    // from the current scope.

    // error: call of overloaded ‘display(int)’ is ambiguous
    // display(2);

    ::display(2);
    A::display(2);
}